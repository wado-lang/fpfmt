// Copyright 2025 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Port of pow10gen.go. Generates src/pow10tab.rs.
//
// Usage: cargo run -p pow10gen

use std::cmp::Ordering;
use std::fmt::Write;
use std::fs;

use num_bigint::BigUint;
use num_integer::Integer;
use num_traits::Zero;

const MIN_EXP: i64 = -348;
const MAX_EXP: i64 = 347;

fn main() {
    let ten = BigUint::from(10u64);
    let b1p64 = BigUint::from(1u64) << 64;
    let b1p128 = BigUint::from(1u64) << 128;

    let mut out = String::new();
    writeln!(
        out,
        "\
// Code generated by: cargo run -p pow10gen. DO NOT EDIT.

#![allow(dead_code, clippy::unreadable_literal)]

use super::PmHiLo;

pub(crate) const POW10_MIN: i32 = {MIN_EXP};
pub(crate) const POW10_MAX: i32 = {MAX_EXP};

/// `pow10_tab` holds 128-bit mantissas of powers of 10.
/// The values are scaled so the high bit is always set.
pub(crate) static POW10_TAB: [PmHiLo; {}] = [",
        MAX_EXP - MIN_EXP + 1,
    )
    .unwrap();

    for e in MIN_EXP..=MAX_EXP {
        // r = 10^e as a rational (num/denom).
        let (mut num, mut denom) = if e >= 0 {
            (ten.pow(e as u32), BigUint::from(1u64))
        } else {
            (BigUint::from(1u64), ten.pow((-e) as u32))
        };

        let mut be: i64 = 0;
        // while r < 2^128: r *= 2
        while num.cmp(&(&denom * &b1p128)) == Ordering::Less {
            num <<= 1;
            be += 1;
        }
        // while r >= 2^128: r /= 2
        while num.cmp(&(&denom * &b1p128)) != Ordering::Less {
            denom <<= 1;
            be -= 1;
        }

        let d = &num / &denom;
        let (hi, lo) = d.div_mod_floor(&b1p64);
        let mut uhi = u64_from(&hi);
        let mut ulo = u64_from(&lo);

        // Round up if not exact.
        if !(&num % &denom).is_zero() {
            ulo = ulo.wrapping_add(1);
            if ulo == 0 {
                uhi += 1;
            }
        }
        // Convert to hi<<64 - lo representation.
        if ulo != 0 {
            uhi += 1;
            ulo = ulo.wrapping_neg();
        }

        writeln!(
            out,
            "    PmHiLo {{ hi: {uhi:#018x}, lo: {ulo:#018x} }}, // 1e{e} * 2**{be}",
        )
        .unwrap();
    }

    out.push_str("];\n");
    fs::write("src/pow10tab.rs", &out).expect("failed to write src/pow10tab.rs");
}

/// Extract the low 64 bits from a [`BigUint`].
fn u64_from(x: &BigUint) -> u64 {
    let digits = x.to_u64_digits();
    if digits.is_empty() { 0 } else { digits[0] }
}
